# Contributing

## Building/Testing

``` shell
$ nix develop;
$ make;
$ ls ./bin/;
pkgdb
$ make check;
...<SNIP>...
```


## Building Docs

Docs are generated by [Doxygen](https://www.doxygen.nl/).

```shell
$ nix develop;
$ make doc;
$ firefox ./docs/index.html;
```


## Making a Release

This project follows semantic version guidelines with then
scheme `<MAJOR>.<MINOR>.<PATCH>`.

This means that when a release is created, the version number should be
incremented using the following rules:

- _Bug Fixes_ and _Optimizations_ which have no effect on the availability of
  public interfaces should increment _patch_ version.
  + When users see that _patch_ was incremented they expect to update `pkgdb`
    without making ANY changes to their existing usage.
  + If you didn't add any new features, and you didn't break existing tests,
    you should probably bump this.
- _New Features_ and _Interfaces_ such as new subcommands/flags, new C++
  interfaces/class member variables defined in any `<pkgdb>/include/` file, or
  any change which does not otherwise effect backwards compatibility should
  increment _minor_ version.
  + When users see that _minor_ was incremented they expect to update `pkgdb`
    without making changes to their existing usage, but they may be able to take
    advantage of new features if they choose to.
  + The user should expect that existing databases may be migrated to new
    schemas ( or regenerated ) automatically.
  + If you added a new feature be sure to add new tests as well.
    If you didn't break any existing tests that should help reassure you that
    _minor_ is safe to bump.
    If you break unit tests you may want to investigate and confirm whether
    these test "public" interfaces, or internals - if you didn't break any
    public interfaces this should help reassure you that _minor_ is safe
    to bump.
- _Removed Features_ or _Breaking Changes_ such as removed subcommands/flags,
  removed interfaces/class member variables defined in any `<pkgdb>/include/`
  file, or any change which may break existing usage patterns should increment
  _major_ version.
  + When users see that _major_ version was incremented they know that they
    should only perform an update if they have available time migrate some
    existing usage of `pkgdb` in their software.
  + If you break any integration tests and need to modify their output, you
    almost certainly need to bump the _major_ version.
    If you break unit tests of public interfaces you should bump
    _major_ version.
    
Follow the rules above strictly, and while we ideally want to avoid bumping
major versions when possible - do not concern yourself with
"having a high version number".

Semantic version numbers are not used in marketing materials, and are intended
to indicate certain categories of software changes to developers and automated
tools ( particularly CI/CD integration test suites ).
These readers could care less if `pkgdb` is at version 3.2.1 or 30000.2.1!


### SQL Schema Version
Changes to the `pkgdb` SQL schema should be indicated by semantic version
numbers in the file `<pkgdb>/include/pkgdb.hh` using the variable
`FLOX_PKGDB_SCHEMA_VERSION` which is used to populate newly created DBs and to
detect old schemas in existing DBs.

Any changes to the schema version number should also trigger an equivalent
increment to the `pkgdb` version number.


### `pkgdb` Software Versioning
Updates to `pkgdb` version numbers are controlled by the text file
`<pkgdb>/version` ( in the repository root ).
This file is used to populate the CPP variable `FLOX_PKGDB_VERSION`, the `nix`
derivation's version number, and the `pkg-config` manifest file's version.

Publishing releases on GitHub using their WebUI is recommended AFTER you've
followed the process for creating/updating release tags described below.

#### Creating Release Tags

Tagging release commits as `v<MAJOR>.<MINOR>.<PATCH>` is required, including
aliases for `latest`, `v<MAJOR>`, and `v<MAJOR>.<MINOR>`.
These tags are used by consuming repositories to detect breaking changes in
public interfaces and minimum usable `v<MAJOR>.<MINOR>` version
( to have access to certain features ).
This allows automated `update`/`upgrade` utilities to be used at scale.


For example lets say that we are releasing a new minor version which moves us
from `v4.1.3` to `v4.2.0`, we would perform the following:
```shell
# Make sure we're up to date, and on `main'.
$ git fetch;
$ git checkout main;

$ OLD_VERSION="$( < ./version; )";
# Modify old version, you can do this manually or using `semver'
# ( available in the `nix develop' shell ).
$ nix develop -c semver -i minor "$OLD_VERSION" > version;

$ NEW_VERSION="$( < ./version; )";
$ echo "$NEW_VERSION";
4.2.0

# Make a release commit
$ git add ./version;
$ git commit -m "release v$NEW_VERSION";

# Tag `HEAD' with the full `v<MAJOR>.<MINOR>.<PATCH>'
$ git tag -a "v$NEW_VERSION" -m "release v$NEW_VERSION";

# Push the release commit
$ git push;

# Update alias tags

# Point `v<MAJOR>.<MINOR>' to new release.
$ git tag -f "v${NEW_VERSION%.*}" "v$NEW_VERSION";

# Point `v<MAJOR>' to `v<MAJOR>.<MINOR>'.
$ git tag -f "v${NEW_VERSION%%.*}" "v${NEW_VERSION%.*}";

# Point `latest' to `v<MAJOR>'.
$ git tag -f 'latest' "v${NEW_VERSION%%.*}";

# Push the tags!
$ git push origin --tags --force;
```
